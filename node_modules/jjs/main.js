//Poloyfill for Object.create
if (!Object.create) {
    Object.create = function (o) {
        if (arguments.length > 1) {
            throw new Error('Object.create implementation only accepts the first parameter.');
        }
        function F() {}
        F.prototype = o;
        return new F();
    };
}
//Polyfill for Array.forEach
if ( !Array.prototype.forEach ) {
    Array.prototype.forEach = function(fn, scope) {
        for(var i = 0, len = this.length; i < len; ++i) {
            fn.call(scope, this[i], i, this);
        }
    };
}

function isHTML(el){
    return (el instanceof (HTMLElement || Element));
}

(function(global) {
    
    //Detect environment
    global.isBrowser = (typeof global.window !== 'undefined');
        
    //Private object for holding the plugins and basic functions
    var _jj = {
        isBrowser : global.isBrowser,
        plugins: {},
        utilies : {
            create : function(object, extendingObject){
                extendingObject = extendingObject || {};
                //Check, if Element is a DOM Node - in this case, we don't create a new object
                var clone = global.isBrowser && isHTML(object) ? object : Object.create(object),
                    protoAccess = (Object.getPrototypeOf) ? (Object.getPrototypeOf({ __proto__: null }) === null) : (false);
        
                if(!protoAccess || (global.isBrowser && isHTML(clone))){
                    this.extend(clone, extendingObject);
                    return clone;
                }
                else {
                    extendingObject.__proto__ = clone;
                    return extendingObject;
                }
            },
            // "Classical" way to create an object - iterating though the original object and modify it*/
            extend : function(object, extendingObject){
                for (var key in extendingObject){
                    object[key] = extendingObject[key];
                }
                return object;
            },
            copy : function(object){
                var copy = this.create(object);
                //Clone object literals, otherwise the copy would reference the original
                for(var i in object){
                    if(typeof object[i] === 'object' && object.hasOwnProperty(i)){
                        var methods = {};
                        copy[i] = this.clone(copy[i]);
                    }
                }
                return copy;
            },
            clone : function(object){
                var _self = this,
                    _methods = {};
                return JSON.parse(JSON.stringify(object, function(key, value){
                    if(typeof value === 'function'){
                        _methods[key] = value;
                        return '__FUNCTION__';
                    }
                    return value;
                }), function(key, value){
                    if(value === '__FUNCTION__' && typeof _methods[key] === 'function'){
                        return _methods[key];
                    }
                    return value;
                });
            }
        },
        setups : {
            registry : {
                'eventobserver' : {}
            }
        }
    };
    
    //The JJ function wich executes the obj plugin
    var jj = function(){
       if(arguments.length > 0){ 
            return jj.obj(arguments[0]);
       }
    };
    
    
    /* ::::::::::::::::::::::::::::::: 
     * ::::::::: REGISTRY ::::::::::::
     * ::::::::::::::::::::::::::::::: */
    
    jj.registry = _jj.utilies.copy(_jj.setups.registry);
    jj.registry.global = jj;
    
    jj.set =  function(name, object, global){
        var instance = global ? jj : this,
            name = name.toString();
        instance.registry[name] = object;
        return this;
    };
    
    jj.push = function(name, object, global){
        var instance = global ? jj : this;
        //var instance = this;
        if(jj.getType(instance.registry[name]) !== 'array'){
            instance.registry[name] = [];
        }
        instance.registry[name].push(object);

        return this;
    };
    
    jj.remove = function(name, global){
        var instance = global ? jj : this;
        instance.registry[name] = null;
    };
    
    jj.get = function(name){
        return this.registry[name];
    };
    
    jj.on = function(events, func, reset, global){
        var self = this,
            o = this.get('eventobserver');
        if(typeof func === 'function'){
            this.obj(events).execute(function(){
                if(reset){
                    self.set(this, []);
                    (global ? jj : self).remove(this + '::added');
                }
                self.push(this, func, global);
                if(o[this]){
                    (global ? jj : self).trigger(this + '::added', func);
                }
            });
        }
        return this;
    };
    
    jj.observe = function(event, func, global){
        var observer = this.get('eventobserver');
        observer[event] = true;
        this.on(event + '::added', func, null, global);
    };
    
    jj.execQueue =  function(q, e){
        var self = this;
        self.obj(q).execute(function(){
            if(this._e === e.toString()){
                var funcs = self.registry[e],
                    trigger = this;
                self.obj(funcs).execute(function(){
                    if(typeof this === 'function'){
                        q.splice(q.indexOf(trigger), 1);
                        this.apply(self, trigger._a);
                    }
                });
            }
        });
        return this;
    };
    
    jj.trigger = function(){
        var global = this === jj ? true : false;
        var self = this,
            event = arguments[0],
            args = [].slice.call(arguments, 1),
            funcs = self.registry[event] || [],
            pluginFunc = this['on' + event[0].toUpperCase() + event.slice(1)];

        if(typeof pluginFunc === 'function'){
            funcs.push(pluginFunc);
        }
        this.obj(funcs).execute(function(){
            this.apply(self, args);
        });
        
        //last argument can be used as config arguments
        var config = args[args.length - 1];
        //Observe if new event handlers will be added and execute them immedeately
        if(config && typeof config.state !== 'undefined' && config.state){
            if(event.indexOf('::added') === -1){
                this.observe(event, function(func){
                    func.apply(self, args);
                }, global);
            }
        }
        return self;
    };
        
    jj.destroy = function(){
        this.trigger('destroy').reset();
    };
    
    jj.reset = function(){
        this.registry = _jj.utilies.copy(_jj.setups.registry);
    };

    //utilies for working with objects
    _jj.obj = function(){
        
        return {
            init: function(){
                return this.setObject(arguments[0]);
            },
            setObject : function(value){
                if(typeof value !== 'undefined'){
                    this.set('object', value, false);
                }
                return this;
            },
            
            getObject : function(){
                return this.get('object');
            },
            
            toAbstract : function(){

                //Create an object, which uses the original object as prototype
                //Override all methods so that they become abstract methodes

                var abstractObject = this.getObject();

                for (var key in abstractObject){
                    if(typeof abstractObject[key] === 'function'){
                        abstractObject[key] = function(){
                            throw new Error(key + ' is a abstract method. You need to override it.');
                        }
                    }
                }
                return this;
            },
            
            create: function(extendingObject){
                this.setObject(_jj.utilies.create(this.getObject(), extendingObject));
                return this; 
            },
                    
            copy: function(){
                this.setObject(_jj.utilies.copy(this.getObject()));
                return this; 
            },
            
            extend: function(extendingObject){
                this.setObject(_jj.utilies.extend(this.getObject(), extendingObject));
                return this;                
            }
        }
    }();
    
    //Class to type, adapted from jQuery
    _jj.class2type = [];
    ("Boolean NodeList Number String Function Array Date RegExp Object").split(" ").forEach(function(entry){
        _jj.class2type[ "[object " + entry + "]" ] = entry.toLowerCase();
    });
    
    jj.getType = function(obj){
    return obj == null ?
            String( obj ) :
            _jj.class2type[ Object.prototype.toString.call(obj)  ] || "object";    
    }

    jj.isDom = function(object){
        if(this.getType(object) === 'nodelist') return true;
        return (global.isBrowser && isHTML(object));
    };
    
    //Execute something with an object;
    _jj.execute = {
            init: function(callback){
                //Check if object is numerable
                var object = this.get('object');
                if(typeof object === 'undefined' || object === null)
                    return this;
               (this['handle' + (this.isDom(object) ? 'dom' : this.getType(object))] || this['handledefault']).
                    call(this, object, callback);
                return this;
            },
                    
            iterate: function(object, callback){
                for(var i = 0; i < object.length; i++){
                    callback.call(object[i], this);
                }        
            },
                    
            handlestring: function(object, callback){
                callback.call(object.toString(), this);
            },
            
            handledefault: function(object, callback){
                return typeof object.length !== 'undefined' ? 
                    this.iterate(object, callback) : callback.call(object, this);
            },
            
            handledom: function(object, callback){
                return this.getType(object) === 'nodelist' ?
                    this.iterate(object, callback) : callback.call(object, this);
            }
    };
             

    
    //Special method, for setting plugins with abilities of jj
    jj.setPlugin = function(name, object, extendingObject){
        
        if(!name || !object){
            return this;
        }
        if(object.constructor !== Object || typeof object.prototype !== 'undefined'){
            //Given Object must be called as a constructor function
            //Create method for creating a new instance
            var params,
                F = function(){
                    return object.apply(this, params);
                };
            F.prototype = object.prototype;
            var plugin = {
                init: function(){
                    params = arguments;
                    try{var instance = new F();}
                    catch(e){var instance = new object();}

                    var extendedObject = (typeof extendingObject !== 'undefined') ? _jj.utilies.extend(instance, extendingObject) : instance;
                    var jjObject = _jj.utilies.extend(extendedObject, jj);
                    return jjObject;
                }
            };
        }
        else {
            var object = (typeof extendingObject !== 'undefined') ? _jj.utilies.create(object, extendingObject) : object;
            var plugin = _jj.utilies.create(jj, object);
        }
        
        _jj.plugins[name] = plugin;

        //Create method for creating a new object with plugin prototype
        this[name] = function(initObject){
            //Create an copy of the plugin object
            var _plugin = _jj.utilies.copy(_jj.plugins[name]);

            //Set current registry to the registry of the plugin
            _plugin.registry = _jj.utilies.create(this.registry, {});
            
            //Check if plugin has an init function and execute it
            if(typeof _plugin.init === 'function'){
                return (arguments.length > 0) ? _plugin.init.apply(_plugin, arguments) : _plugin.init();

            }
            else {
                return _plugin;
            }
        };

        return this;
        
    };
    
    //Special function for requireJS
    jj.load = function (name, parentRequire, onload, config){
        var title = name.split('/')[0];
        //Check plugins, which are not specified in an external script
        if(config.jj.plugins && !config.jj.plugins.loaded){
            for(var pluginName in config.jj.plugins){
                jj.setPlugin(pluginName, config.jj.plugins[pluginName]);
            }
            config.jj.plugins.loaded = true;
        }
        
        //Don't set a plugin twice
        if(_jj.plugins[title]){
            onload();
            return false;
        }
        
        parentRequire([name], function (value) {
            jj.setPlugin(title, value);
            onload(value);
        });
    };
    
    //Set standard plugins
    jj.
        setPlugin('obj', _jj.obj).
        setPlugin('execute', _jj.execute);

   
  /* MODULE EXPORT */
 
  if(typeof process !== 'undefined'){
        //Script is executed via command line - check, if it's the build process of requirejs
        global.define = function(){
            var b;
            process.argv.forEach(function(val){
                b = val.indexOf('requirejs') > -1 ? {amd: true} : false;
            });
            return b;
        }();
  }
  
  if (global.define && global.define.amd) {
    // Publish as AMD module
    return define(function() {return jj;});
  }
  
  if (typeof(module) !== 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = jj;
    return;
  }
  
}(typeof window !== "undefined" ? window : this));
